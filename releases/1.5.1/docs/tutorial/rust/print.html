<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Slint Memory Game Tutorial (Rust)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!--
            This file is used to add syntax highlighting of the `.slint` snippets in the generated rustdoc, sphinx and mdbook documentation.
            It can be injected via the `--html-in-header slint-docs-highlight.html` option of rustdoc, is included via _templates/layout.html
            in sphinx and via head.hbs in mdbook.
        -->
        <link rel="stylesheet" href="https://slint.dev/resources/highlightjs/11.0.1/default.min.css">
        <script src="https://slint.dev/resources/highlightjs/11.0.1/highlight.min.js"></script>
        <script>
          function highlight_slint(hljs) {
            const KEYWORDS = {
              keyword:
                "animate callback component export for function global if import in in-out inherits out parent private property public pure root self signal states struct transitions",
              literal: "false true",
              built_in:
                "ArcTo Clip Close Colors CubicTo Flickable FocusScope GridLayout HorizontalLayout Image LineTo Math MoveTo Path PopupWindow QuadraticTo Rectangle Row Text TextInput TouchArea VerticalLayout Window animation-tick debug",
              type: "bool duration easing float int length logical_length relative-font-size resource string",
            };
        
            return {
              name: 'slint',
              case_insensitive: false,
              keywords: KEYWORDS,
              contains: [
                hljs.QUOTE_STRING_MODE,
                hljs.C_LINE_COMMENT_MODE,
                hljs.C_BLOCK_COMMENT_MODE,
                hljs.COMMENT('/\\*', '\\*/', {
                  contains: ['self']
                }),
                {
                  className: 'number',
                  begin: '\\b\\d+(\\.\\d+)?(\\w+)?',
                  relevance: 0
                },
                {
                  className: 'title',
                  begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]* *:=',
                },
                {
                  className: 'symbol',
                  begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]*(:| *=>)',
                },
                {
                  className: 'built_in',
                  begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]*!',
                },
              ],
              illegal: /@/
            };
          };
        
          // Tags used in fenced code blocks
          for (let tag of ["slint", "slint,no-preview", "slint,no-auto-preview", "slint,ignore"]) {
            hljs.registerLanguage(tag, highlight_slint);
          }
        
        
          window.addEventListener("DOMContentLoaded", () => {
            const rustDoc = document.querySelector('meta[name="generator"]')?.content == "rustdoc";
            if (rustDoc) {
              // Only highlight .slint blocks, leave the others to rustdoc
              for (slintBlock of document.querySelectorAll("[class*=language-slint]")) {
                hljs.highlightElement(slintBlock)
              }
        
              // Some of the rustdoc selectors require the pre element to have the rust class
              for (codeBlock of document.querySelectorAll(".language-slint.hljs")) {
                codeBlock.parentElement.classList.add("rust")
              }
        
              // Change the hljs generated classes to the rustdoc
              // ones, so that the highlighting adjusts to the theme correctly.
              const highlightJSToRustDoc = [
                ["comment", "comment"],
                ["number", "number"],
                ["symbol", "struct"], // width:
                ["keyword", "kw"],
                ["built_in", "primitive"],
                ["string", "string"],
                ["title", "fnname"], // Foo :=
                ["type", "type"]
              ];
        
              for ([hljs_class, rustdoc_class] of highlightJSToRustDoc) {
                for (titleElement of document.querySelectorAll(`.hljs-${hljs_class}`)) {
                  titleElement.classList.remove(`hljs-${hljs_class}`);
                  titleElement.classList.add(rustdoc_class);
                }
              }
            } else {
              // For use with the mdbook Tutorial
              hljs.highlightAll();
        
              // The Sphinx/my_st generated HTML for code blocks doesn't use <code> tags, so highlight.js'
              // default selector "pre code" doesn't match. Let's do it by hand:
              for (block of document.querySelectorAll("div[class*=highlight-slint] div.highlight pre")) {
                hljs.highlightElement(block)
              }
            }
          });
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="memory_tile.html"><strong aria-hidden="true">3.</strong> Memory Tile</a></li><li class="chapter-item expanded "><a href="polishing_the_tile.html"><strong aria-hidden="true">4.</strong> Polishing the Tile</a></li><li class="chapter-item expanded "><a href="from_one_to_multiple_tiles.html"><strong aria-hidden="true">5.</strong> From One To Multiple Tiles</a></li><li class="chapter-item expanded "><a href="creating_the_tiles_from_rust.html"><strong aria-hidden="true">6.</strong> Creating The Tiles From Rust</a></li><li class="chapter-item expanded "><a href="game_logic_in_rust.html"><strong aria-hidden="true">7.</strong> Game Logic In Rust</a></li><li class="chapter-item expanded "><a href="ideas_for_the_reader.html"><strong aria-hidden="true">8.</strong> Ideas For The Reader</a></li><li class="chapter-item expanded "><a href="running_in_a_browser.html"><strong aria-hidden="true">9.</strong> Running In A Browser Using WebAssembly</a></li><li class="chapter-item expanded "><a href="conclusion.html"><strong aria-hidden="true">10.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Slint Memory Game Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This tutorial introduces you to the Slint UI framework in a playful way by implementing a memory game. It combines the Slint language for the graphics with the game rules implemented in Rust.</p>
<p>The game consists of a grid of 16 rectangular tiles. Clicking on a tile uncovers an icon underneath.
There are 8 different icons in total, so each tile has a sibling somewhere in the grid with the
same icon. The objective is to locate all icon pairs. The player can uncover two tiles at the same time. If they
aren't the same, the game obscures the icons again.
If the player uncovers two tiles with the same icon, then they remain visible - they're solved.</p>
<p>This is how the game looks in action:</p>
<p><video autoplay loop muted playsinline src="https://slint.dev/blog/memory-game-tutorial/memory_clip.mp4"
        class="img-fluid img-thumbnail rounded"></video></p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This tutorial uses Rust as the host programming language. Slint also supports other programming languages like
<a href="https://slint.dev/docs/cpp/">C++</a> or <a href="https://slint.dev/docs/node/">JavaScript</a>.</p>
<p>We recommend using <a href="https://rust-analyzer.github.io">rust-analyzer</a> and <a href="https://github.com/slint-ui/slint/tree/master/editors">our editor integrations for Slint</a> for following this tutorial.</p>
<p>Slint has an application template you can use to create a project with dependencies already set up that follows recommended best practices.</p>
<p>Before using the template, install <code>[cargo-generate](https://github.com/cargo-generate/cargo-generate)</code>:</p>
<pre><code class="language-sh">cargo install cargo-generate
</code></pre>
<p>Use the template to create a new project with the following command:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/slint-ui/slint-rust-template --name memory
cd memory
</code></pre>
<p>Replace the contents of <code>src/main.rs</code> with the following:</p>
<pre><code class="language-rust noplayground">fn main() {
    MainWindow::new().unwrap().run().unwrap();
}

slint::slint! {
    export component MainWindow inherits Window {
        Text {
            text: "hello world";
            color: green;
        }
    }
}</code></pre>
<p>Run the example with <code>cargo run</code> and a window appears with the green "Hello World" greeting.</p>
<p><img src="https://slint.dev/blog/memory-game-tutorial/getting-started.png" alt="Screenshot of an initial tutorial app showing Hello World" title="Hello World" /></p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="memory-tile"><a class="header" href="#memory-tile">Memory Tile</a></h1>
<p>With the skeleton code in place, this step looks at the first element of the game, the memory tile. It's the
visual building block that consists of an underlying filled rectangle background, the icon image. Later steps add a covering rectangle that acts as a curtain.</p>
<p>You declare the background rectangle as 64 logical pixels wide and tall
filled with a soothing tone of blue.</p>
<p>Lengths in Slint have a unit, here, the <code>px</code> suffix.
This makes the code easier to read and the compiler can detect when you accidentally
mix values with different units attached to them.</p>
<p>Copy the following code inside of the <code>slint!</code> macro, replacing the current content:</p>
<pre><code class="language-slint">component MemoryTile inherits Rectangle {
    width: 64px;
    height: 64px;
    background: #3960D5;

    Image {
        source: @image-url("icons/bus.png");
        width: parent.width;
        height: parent.height;
    }
}

export component MainWindow inherits Window {
    MemoryTile {}
}
</code></pre>
<p>Inside the <span class="hljs-built_in">Rectangle</span> place an <span class="hljs-built_in">Image</span> element that
loads an icon with the <span class="hljs-built_in">@image-url()</span> macro.</p>
<p>When using the <code>slint!</code> macro, the path is relative to the folder that contains the <code>Cargo.toml</code> file.
When using Slint files, it's relative to the folder of the Slint file containing it.</p>
<p>You need to install this icon and others you use later first. You can download a pre-prepared
<a href="https://slint.dev/blog/memory-game-tutorial/icons.zip">Zip archive</a> and extract it with the
following commands:</p>
<pre><code class="language-sh">curl -O https://slint.dev/blog/memory-game-tutorial/icons.zip
unzip icons.zip
</code></pre>
<p>This unpacks an <code>icons</code> directory containing several icons.</p>
<p>Running the program with <code>cargo run</code> opens a window that shows the icon of a bus on a
blue background.</p>
<p><img src="https://slint.dev/blog/memory-game-tutorial/memory-tile.png" alt="Screenshot of the first tile" title="Memory Tile Screenshot" /></p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="polishing-the-tile"><a class="header" href="#polishing-the-tile">Polishing the Tile</a></h1>
<p>In this step, you add a curtain-like cover that opens when clicked. You do this by declaring two rectangles
below the <span class="hljs-built_in">Image</span>, so that Slint draws them after the Image and thus on top of the image.</p>
<p>The <span class="hljs-built_in">TouchArea</span> element declares a transparent rectangular region that allows
reacting to user input such as a mouse click or tap. The element forwards a callback to the <em>MainWindow</em> indicating that a user clicked the tile.</p>
<p>The <em>MainWindow</em> reacts by flipping a custom <em>open_curtain</em> property.
Property bindings for the animated width and x properties also use the custom <em>open_curtain</em> property.</p>
<p>The following table shows more detail on the two states:</p>
<div class="table-wrapper"><table><thead><tr><th><em>open_curtain</em> value:</th><th>false</th><th>true</th></tr></thead><tbody>
<tr><td>Left curtain rectangle</td><td>Fill the left half by setting the width <em>width</em> to half the parent's width</td><td>Width of zero makes the rectangle invisible</td></tr>
<tr><td>Right curtain rectangle</td><td>Fill the right half by setting <em>x</em> and <em>width</em> to half of the parent's width</td><td><em>width</em> of zero makes the rectangle invisible. <em>x</em> moves to the right, sliding the curtain open when animated</td></tr>
</tbody></table>
</div>
<p>To make the tile extensible, replace the hard-coded icon name with an <em>icon</em>
property that can be set when instantiating the element.</p>
<p>For the final polish, add a
<em>solved</em> property used to animate the color to a shade of green when a player finds a pair.</p>
<p>Replace the code inside the <code>slint!</code> macro with the following:</p>
<pre><code class="language-slint">component MemoryTile inherits Rectangle {
    callback clicked;
    in property &lt;bool&gt; open_curtain;
    in property &lt;bool&gt; solved;
    in property &lt;image&gt; icon;

    height: 64px;
    width: 64px;
    background: solved ? #34CE57 : #3960D5;
    animate background { duration: 800ms; }

    Image {
        source: icon;
        width: parent.width;
        height: parent.height;
    }

    // Left curtain
    Rectangle {
        background: #193076;
        x: 0px;
        width: open_curtain ? 0px : (parent.width / 2);
        height: parent.height;
        animate width { duration: 250ms; easing: ease-in; }
    }

    // Right curtain
    Rectangle {
        background: #193076;
        x: open_curtain ? parent.width : (parent.width / 2);
        width: open_curtain ? 0px : (parent.width / 2);
        height: parent.height;
        animate width { duration: 250ms; easing: ease-in; }
        animate x { duration: 250ms; easing: ease-in; }
    }

    TouchArea {
        clicked =&gt; {
            // Delegate to the user of this element
            root.clicked();
        }
    }
}

export component MainWindow inherits Window {
    MemoryTile {
        icon: @image-url("icons/bus.png");
        clicked =&gt; {
            self.open_curtain = !self.open_curtain;
        }
    }
}
</code></pre>
<p>The code uses <code>root</code> and <code>self</code>. <code>root</code> refers to the outermost
element in the component, the <span class="hljs-title">MemoryTile</span> in this case. <code>self</code> refers
to the current element.</p>
<p>The code exports the <span class="hljs-title">MainWindow</span> component. This is necessary so that you can later access it
from application business logic.</p>
<p>Running the code opens a window with a rectangle that opens up to show the bus icon when clicked. Subsequent clicks close and open the curtain again.</p>
<p><video autoplay loop muted playsinline src="https://slint.dev/blog/memory-game-tutorial/polishing-the-tile.mp4"></video></p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="from-one-to-multiple-tiles"><a class="header" href="#from-one-to-multiple-tiles">From One To Multiple Tiles</a></h1>
<p>After modeling a single tile, this step creates a grid of them. For the grid to be a game board, you need two features:</p>
<ol>
<li>
<p><strong>A data model</strong>: An array created as a Rust model, where each element describes the tile data structure, such as:</p>
<ul>
<li>URL of the image</li>
<li>Whether the image is visible</li>
<li>If the player has solved this tile.</li>
</ul>
</li>
<li>
<p>A way of creating multiple instances of the tiles.</p>
</li>
</ol>
<p>With Slint you declare an array of structures based on a model using square brackets. Use a <span class="hljs-keyword">for</span> loop
to create multiple instances of the same element.</p>
<p>The <span class="hljs-keyword">for</span> loop is declarative and automatically updates when
the model changes. The loop instantiates all the <span class="hljs-title">MemoryTile</span> elements and places them on a grid based on their
index with spacing between the tiles.</p>
<p>First, add the tile data structure definition at the top of the <code>slint!</code> macro:</p>
<pre><code class="language-slint">
struct TileData {
    image: image,
    image_visible: bool,
    solved: bool,
}

</code></pre>
<p>Next, replace the <em>export component <span class="hljs-title">MainWindow</span> inherits Window { ... }</em> section at the bottom of the <code>slint!</code> macro with the following:</p>
<pre><code class="language-slint">export component MainWindow inherits Window {
    width: 326px;
    height: 326px;

    in property &lt;[TileData]&gt; memory_tiles: [
        { image: @image-url("icons/at.png") },
        { image: @image-url("icons/balance-scale.png") },
        { image: @image-url("icons/bicycle.png") },
        { image: @image-url("icons/bus.png") },
        { image: @image-url("icons/cloud.png") },
        { image: @image-url("icons/cogs.png") },
        { image: @image-url("icons/motorcycle.png") },
        { image: @image-url("icons/video.png") },
    ];
    for tile[i] in memory_tiles : MemoryTile {
        x: mod(i, 4) * 74px;
        y: floor(i / 4) * 74px;
        width: 64px;
        height: 64px;
        icon: tile.image;
        open_curtain: tile.image_visible || tile.solved;
        // propagate the solved status from the model to the tile
        solved: tile.solved;
        clicked =&gt; {
            tile.image_visible = !tile.image_visible;
        }
    }
}
</code></pre>
<p>The <code><span class="hljs-keyword">for</span> tile[i] <span class="hljs-keyword">in</span> memory_tiles:</code> syntax declares a variable <code>tile</code> which contains the data of one element from the <code>memory_tiles</code> array,
and a variable <code>i</code> which is the index of the tile. The code uses the <code>i</code> index to calculate the position of a tile, based on its row and column,
using modulo and integer division to create a 4 by 4 grid.</p>
<p>Running the code opens a window that shows 8 tiles, which a player can open individually.</p>
<p><video autoplay loop muted playsinline src="https://slint.dev/blog/memory-game-tutorial/from-one-to-multiple-tiles.mp4"></video></p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="creating-the-tiles-from-rust"><a class="header" href="#creating-the-tiles-from-rust">Creating The Tiles From Rust</a></h1>
<p>This step places the game tiles randomly. The code uses the <code>rand</code> dependency for the randomization. Add it to the <code>Cargo.toml</code> file using the <code>cargo</code> command.</p>
<pre><code class="language-sh">cargo add rand@0.8
</code></pre>
<p>Change the main function to the following:</p>
<pre><code class="language-rust noplayground">fn main() {
    use slint::Model;

    let main_window = MainWindow::new().unwrap();

    // Fetch the tiles from the model
    let mut tiles: Vec&lt;TileData&gt; = main_window.get_memory_tiles().iter().collect();
    // Duplicate them to ensure that we have pairs
    tiles.extend(tiles.clone());

    // Randomly mix the tiles
    use rand::seq::SliceRandom;
    let mut rng = rand::thread_rng();
    tiles.shuffle(&amp;mut rng);

    // Assign the shuffled Vec to the model property
    let tiles_model = std::rc::Rc::new(slint::VecModel::from(tiles));
    main_window.set_memory_tiles(tiles_model.into());

    main_window.run().unwrap();
}
</code></pre>
<p>The code takes the list of tiles, duplicates it, and shuffles it, accessing the <code>memory_tiles</code> property through the Rust code.</p>
<p>For each top-level property,
Slint generates a getter and a setter function. In this case <code>get_memory_tiles</code> and <code>set_memory_tiles</code>.
Since <code>memory_tiles</code> is a Slint array represented as a <a href="https://slint.dev/docs/rust/slint/trait.Model"><code>Rc&lt;dyn slint::Model&gt;</code></a>.</p>
<p>You can't change the model generated by Slint, but you can extract the tiles from it and put them
in a <a href="https://slint.dev/docs/rust/slint/struct.VecModel"><code>VecModel</code></a> which implements the <code>Model</code> trait.
<code>VecModel</code> lets you make changes and you can use it to replace the static generated model.</p>
<p>The code clones the <code>tiles_model</code> because you use it later to update the game logic.</p>
<p>Running this code opens a window that now shows a 4 by 4 grid of rectangles, which show or hide
the icons when a player clicks on them.</p>
<p>There's one last aspect missing now, the rules for the game.</p>
<p><video autoplay loop muted playsinline src="https://slint.dev/blog/memory-game-tutorial/creating-the-tiles-from-rust.mp4"></video></p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="game-logic-in-rust"><a class="header" href="#game-logic-in-rust">Game Logic In Rust</a></h1>
<p>This step implements the rules of the game in Rust.</p>
<p>Slint's general philosophy is that you implement the user interface in Slint and the business logic in your favorite programming
language.</p>
<p>The game rules enforce that at most two tiles have their curtain open. If the tiles match, then the game
considers them solved and they remain open. Otherwise, the game waits briefly so the player can memorize
the location of the icons, and then closes the curtains again.</p>
<p>Add the following code inside the <span class="hljs-title">MainWindow</span> component to signal to the Rust code when the user clicks on a tile.</p>
<pre><code class="language-slint">    export component MainWindow inherits Window {
        width: 326px;
        height: 326px;

        callback check_if_pair_solved(); // Added
        in property &lt;bool&gt; disable_tiles; // Added

        in-out property &lt;[TileData]&gt; memory_tiles: [
           { image: @image-url("icons/at.png") },
</code></pre>
<p>This change adds a way for the <span class="hljs-title">MainWindow</span> to call to the Rust code that it should
check if a player has solved a pair of tiles. The Rust code needs an additional property to toggle to disable further
tile interaction, to prevent the player from opening more tiles than allowed. No cheating allowed!</p>
<p>The last change to the code is to act when the <span class="hljs-title">MemoryTile</span> signals that a player clicked it.</p>
<p>Add the following handler in the <span class="hljs-title">MainWindow</span> <code>for</code> loop <code>clicked</code> handler:</p>
<pre><code class="language-slint">        for tile[i] in memory_tiles : MemoryTile {
            x: mod(i, 4) * 74px;
            y: floor(i / 4) * 74px;
            width: 64px;
            height: 64px;
            icon: tile.image;
            open_curtain: tile.image_visible || tile.solved;
            // propagate the solved status from the model to the tile
            solved: tile.solved;
            clicked =&gt; {
                // old: tile.image_visible = !tile.image_visible;
                // new:
                if (!root.disable_tiles) {
                    tile.image_visible = !tile.image_visible;
                    root.check_if_pair_solved();
                }
            }
        }
</code></pre>
<p>On the Rust side, you can now add a handler to the <code>check_if_pair_solved</code> callback, that checks if a player opened two tiles.
If they match, the code sets the <code>solved</code> property to true in the model. If they don't
match, start a timer that closes the tiles after one second. While the timer is running, disable every tile so
a player can't click anything during this time.</p>
<p>Add this code before the <code>main_window.run().unwrap();</code> call:</p>
<pre><code class="language-rust noplayground">    // Assign the shuffled Vec to the model property
    let tiles_model = std::rc::Rc::new(slint::VecModel::from(tiles));
    main_window.set_memory_tiles(tiles_model.clone().into());

    let main_window_weak = main_window.as_weak();
    main_window.on_check_if_pair_solved(move || {
        let mut flipped_tiles =
            tiles_model.iter().enumerate().filter(|(_, tile)| tile.image_visible &amp;&amp; !tile.solved);

        if let (Some((t1_idx, mut t1)), Some((t2_idx, mut t2))) =
            (flipped_tiles.next(), flipped_tiles.next())
        {
            let is_pair_solved = t1 == t2;
            if is_pair_solved {
                t1.solved = true;
                tiles_model.set_row_data(t1_idx, t1);
                t2.solved = true;
                tiles_model.set_row_data(t2_idx, t2);
            } else {
                let main_window = main_window_weak.unwrap();
                main_window.set_disable_tiles(true);
                let tiles_model = tiles_model.clone();
                slint::Timer::single_shot(std::time::Duration::from_secs(1), move || {
                    main_window.set_disable_tiles(false);
                    t1.image_visible = false;
                    tiles_model.set_row_data(t1_idx, t1);
                    t2.image_visible = false;
                    tiles_model.set_row_data(t2_idx, t2);
                });
            }
        }
    });</code></pre>
<p>The code uses a <a href="https://slint.dev/docs/rust/slint/struct.Weak">Weak</a> pointer of the <code>main_window</code>. This is
important because capturing a copy of the <code>main_window</code> itself within the callback handler would result in circular ownership.
The <code>MainWindow</code> owns the callback handler, which itself owns a reference to the <code>MainWindow</code>, which must be weak
instead of strong to avoid a memory leak.</p>
<p>These were the last changes and running the code opens a window that allows a player to play the game by the rules.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="ideas-for-the-reader"><a class="header" href="#ideas-for-the-reader">Ideas For The Reader</a></h1>
<p>The game is visually bare. Here are some ideas on how you could make further changes to enhance it:</p>
<ul>
<li>
<p>The tiles could have rounded corners, to look less sharp. Use the <a href="https://slint.dev/docs/slint/src/language/builtins/elements#rectangle">border-radius</a>
property of <em><a href="https://slint.dev/docs/slint/src/language/builtins/elements#rectangle">Rectangle</a></em> to achieve that.</p>
</li>
<li>
<p>In real-world memory games, the back of the tiles often have some common graphic. You could add an image with
the help of another <em><a href="https://slint.dev/docs/slint/src/language/builtins/elements#image">Image</a></em>
element. Note that you may have to use <em>Rectangle</em>'s <em>clip property</em>
element around it to ensure that the image is clipped away when the curtain effect opens.</p>
</li>
</ul>
<p>Let us know in the comments on <a href="https://github.com/slint-ui/slint/discussions">Github Discussions</a>
how you polished your code, or feel free to ask questions about how to implement something.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="running-in-a-browser-using-webassembly"><a class="header" href="#running-in-a-browser-using-webassembly">Running In A Browser Using WebAssembly</a></h1>
<p>The tutorial so far used <code>cargo run</code> to build and run the code as a native application.
Native applications are the primary target of the Slint framework, but it also supports WebAssembly
for demonstration purposes. This section uses the standard rust tool <code>wasm-bindgen</code> and
<code>wasm-pack</code> to run the game in the browser. Read the <a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html">wasm-bindgen documentation</a>
for more about using wasm and rust.</p>
<p>Install <code>wasm-pack</code> using cargo:</p>
<pre><code class="language-sh">cargo install wasm-pack
</code></pre>
<p>Edit the <code>Cargo.toml</code> file to add the dependencies.</p>
<pre><code class="language-toml">[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = { version = "0.2" }
getrandom = { version = "0.2.2", features = ["js"] }
</code></pre>
<p><code>'cfg(target_arch = "wasm32")'</code> ensures that these dependencies are only active
when compiling for the wasm32 architecture. Note that the <code>rand</code> dependency is now duplicated,
to enable the <code>"wasm-bindgen"</code> feature.</p>
<p>While you are editing the <code>Cargo.toml</code>, make one last change. To turn the binary into
a library by adding the following:</p>
<pre><code class="language-toml">[lib]
path = "src/main.rs"
crate-type = ["cdylib"]
</code></pre>
<p>This is because wasm-pack requires Rust to generate a <code>"cdylib"</code>.</p>
<p>You also need to change <code>main.rs</code> by adding the <code>wasm_bindgen(start)</code>
attribute to the <code>main</code> function and export it with the <code>pub</code> keyword:</p>
<pre><code class="language-rust noplayground">#[cfg_attr(target_arch = "wasm32",
           wasm_bindgen::prelude::wasm_bindgen(start))]
pub fn main() {
    //...
}</code></pre>
<p>Compile the program with <code>wasm-pack build --release --target web</code>. This
creates a <code>pkg</code> directory containing several files, including a <code>.js</code> file
named after the program name that you need to import into an HTML file.</p>
<p>Create a minimal <code>index.html</code> in the top level of the project that declares a <code>&lt;canvas&gt;</code> element for rendering and loads the generated wasm
file. The Slint runtime expects the <code>&lt;canvas&gt;</code> element to have the id <code>id = "canvas"</code>.
(Replace <code>memory.js</code> with the correct file name).</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;body&gt;
        &lt;!-- canvas required by the Slint runtime --&gt;
        &lt;canvas id="canvas"&gt;&lt;/canvas&gt;
        &lt;script type="module"&gt;
            // import the generated file.
            import init from "./pkg/memory.js";
            init();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Unfortunately, loading ES modules isn't allowed for files on the file system when accessed from a
<code>file://</code> URL, so you can't load the <code>index.html</code>. Instead, you need to serve it through a web server.
For example, using Python, by running:</p>
<pre><code class="language-sh">python3 -m http.server
</code></pre>
<p>Now you can access the game at <a href="http://localhost:8000/">http://localhost:8000</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: MIT -->
<h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>This tutorial showed you how to combine built-in Slint elements with Rust code to build a
game. There is much more to Slint, such as layouts, widgets, or styling.</p>
<p>We recommend the following links to continue:</p>
<ul>
<li><a href="https://github.com/slint-ui/slint/tree/master/examples">Examples</a>: The Slint repository has several demos and examples. These are a great starting point to learn how to use many Slint features.
<ul>
<li><a href="https://github.com/slint-ui/slint/tree/master/examples/todo">Todo Example</a>: This is one of the examples that implements a classic use-case.</li>
<li><a href="https://github.com/slint-ui/slint/tree/master/examples/memory">Memory Puzzle</a>: This is a slightly more polished version of the code in this example and you can <a href="https://slint.dev/demos/memory/" target="_blank">play the wasm version</a> in your browser.</li>
</ul>
</li>
<li><a href="https://slint.dev/docs/rust/slint/">Slint API Docs</a>: The reference documentation for the main Rust crate.</li>
<li><a href="https://slint.dev/docs/rust/slint_interpreter/">Slint Interpreter API Docs</a>: The reference documentation for the Rust crate that allows you to dynamically load Slint files.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
