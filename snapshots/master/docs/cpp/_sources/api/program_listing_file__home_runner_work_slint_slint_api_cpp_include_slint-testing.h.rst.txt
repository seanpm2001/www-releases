
.. _program_listing_file__home_runner_work_slint_slint_api_cpp_include_slint-testing.h:

Program Listing for File slint-testing.h
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_slint_slint_api_cpp_include_slint-testing.h>` (``/home/runner/work/slint/slint/api/cpp/include/slint-testing.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // Copyright Â© SixtyFPS GmbH <info@slint.dev>
   // SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-1.2 OR LicenseRef-Slint-commercial
   
   #include "slint.h"
   #include "slint_testing_internal.h"
   #include <optional>
   #include <string_view>
   
   #ifdef SLINT_FEATURE_TESTING
   
   namespace slint::testing {
   inline void init()
   {
       cbindgen_private::slint_testing_init_backend();
   }
   
   class ElementHandle
   {
       cbindgen_private::ItemRc inner;
   
   public:
       template<typename T>
       static SharedVector<ElementHandle> find_by_accessible_label(const ComponentHandle<T> &component,
                                                                   std::string_view label)
       {
           cbindgen_private::Slice<uint8_t> label_view {
               const_cast<unsigned char *>(reinterpret_cast<const unsigned char *>(label.data())),
               label.size()
           };
           auto vrc = component.into_dyn();
           SharedVector<ElementHandle> result;
           cbindgen_private::slint_testing_element_find_by_accessible_label(
                   &vrc, &label_view,
                   reinterpret_cast<SharedVector<cbindgen_private::ItemRc> *>(&result));
           return result;
       }
   
       std::optional<SharedString> accessible_label() const
       {
           SharedString result;
           if (inner.item_tree.vtable()->accessible_string_property(
                       inner.item_tree.borrow(), inner.index,
                       cbindgen_private::AccessibleStringProperty::Label, &result)) {
               return result;
           } else {
               return std::nullopt;
           }
       }
   
       std::optional<SharedString> accessible_value() const
       {
           SharedString result;
           if (inner.item_tree.vtable()->accessible_string_property(
                       inner.item_tree.borrow(), inner.index,
                       cbindgen_private::AccessibleStringProperty::Value, &result)) {
               return result;
           } else {
               return std::nullopt;
           }
       }
   
       void set_accessible_value(SharedString value) const
       {
           union SetValueHelper {
               cbindgen_private::AccessibilityAction action;
               SetValueHelper(SharedString value)
               // : action { .set_value = { cbindgen_private::AccessibilityAction::Tag::SetValue,
               //                           std::move(value) } }
               {
                   new (&action.set_value) cbindgen_private::AccessibilityAction::SetValue_Body {
                       cbindgen_private::AccessibilityAction::Tag::SetValue, std::move(value)
                   };
               }
               ~SetValueHelper() { action.set_value.~SetValue_Body(); }
   
           } action(std::move(value));
           inner.item_tree.vtable()->accessibility_action(inner.item_tree.borrow(), inner.index,
                                                          &action.action);
       }
   
       void invoke_default_action() const
       {
           union DefaultActionHelper {
               cbindgen_private::AccessibilityAction action;
               DefaultActionHelper()
               //: action { .tag = cbindgen_private::AccessibilityAction::Tag::Default }
               {
                   action.tag = cbindgen_private::AccessibilityAction::Tag::Default;
               }
               ~DefaultActionHelper() { }
   
           } action;
           inner.item_tree.vtable()->accessibility_action(inner.item_tree.borrow(), inner.index,
                                                          &action.action);
       }
   
       LogicalSize size() const
       {
           auto rect = inner.item_tree.vtable()->item_geometry(inner.item_tree.borrow(), inner.index);
           return LogicalSize({ rect.width, rect.height });
       }
   
       LogicalPosition absolute_position() const
       {
           cbindgen_private::LogicalRect rect =
                   inner.item_tree.vtable()->item_geometry(inner.item_tree.borrow(), inner.index);
           cbindgen_private::LogicalPoint abs = slint::cbindgen_private::slint_item_absolute_position(
                   &inner.item_tree, inner.index);
           return LogicalPosition({ abs.x + rect.x, abs.y + rect.y });
       }
   };
   
   }
   
   #endif // SLINT_FEATURE_TESTING
